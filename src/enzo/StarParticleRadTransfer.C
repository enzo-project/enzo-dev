/***********************************************************************
/
/  CONVERT SHINE PARTICLE INTO RADIATIVE TRANSFER PARTICLE
/
/  written by: John Wise
/  date:       November, 2005
/  modified1:
/
/ PURPOSE: This routine converts particles that shone by a 1/r^2 law
/          into particles that utilize an adaptive 3D ray tracing
/          scheme.
/
************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "ErrorExceptions.h"
#include "macros_and_parameters.h"
#include "typedefs.h"
#include "global_data.h"
#include "Fluxes.h"
#include "GridList.h"
#include "ExternalBoundary.h"
#include "Grid.h"
#include "Hierarchy.h"
#include "TopGridData.h"
#include "LevelHierarchy.h"
#include "phys_constants.h"

#define NO_MEAN_ENERGY

int GetUnits(float *DensityUnits, float *LengthUnits,
	     float *TemperatureUnits, float *TimeUnits,
	     float *VelocityUnits, FLOAT Time);

void DeleteGlobalRadiationSources(void);

int StarParticleRadTransfer(LevelHierarchyEntry *LevelArray[], int level,
			    Star *AllStars, float Time)
{

  /* If photon test simulation, don't change the radiation sources. */
  if (ProblemType == 50 || ProblemType == 27)
    return SUCCESS;

  int i, j, nShine, nbins;
  double Q[MAX_ENERGY_BINS], QTotal;
  float qFrac, lramp, energies[MAX_ENERGY_BINS];
  float XRayLuminosityFraction = 0.43;
  Star *cstar;

  /* If sources exist, delete them */

  DeleteGlobalRadiationSources();

  GlobalRadiationSources = new RadiationSourceEntry;
  GlobalRadiationSources->NextSource = NULL;
  GlobalRadiationSources->PreviousSource = NULL;

  if (AllStars == NULL)
    return SUCCESS;

  /* Retrieve the units */

  //FLOAT Time = LevelArray[level]->GridData->ReturnTime();
  float DensityUnits, LengthUnits, TemperatureUnits, TimeUnits,
    VelocityUnits;
  GetUnits(&DensityUnits, &LengthUnits, &TemperatureUnits,
	   &TimeUnits, &VelocityUnits, PhotonTime);

  // Convert from #/s to RT units
  double LConv = (double) TimeUnits / pow(LengthUnits,3);

  // Convert to years
  float TimeInYears = yr_s / TimeUnits;

  for (cstar = AllStars; cstar; cstar = cstar->NextStar) {
    // Check the rules if this star particle is radiative
    if (cstar->IsARadiationSource(PhotonTime)) {
         float dtForThisStar = LevelArray[level]->GridData->ReturnTimeStep();

      // Calculate photon luminosity
      if (cstar->ComputePhotonRates(TimeUnits, Time, nbins, energies, Q, dtForThisStar) == FAIL) {
	ENZO_FAIL("Error in ComputePhotonRates.\n");
      }
      
      QTotal = 0;
      for (j = 0; j < nbins; j++) QTotal += Q[j];
      for (j = 0; j < nbins; j++) Q[j] /= QTotal;
      if (QTotal < tiny_number) continue;

#ifdef USE_MEAN_ENERGY
      double meanEnergy = 0;
      nbins = 1;
      for (j = 0; j < nbins; j++)
	meanEnergy += energies[j] * Q[j];
      meanEnergy /= QTotal;
      energies[0] = meanEnergy;
      Q[0] = QTotal;
#endif /* USE_MEAN_ENERGY */

      /* (TODO) If requested, calculate ramping time for the luminosity */

      float ramptime = 0.0;   // zero for no ramp
      float tdyn, ti;
      if (cstar->ReturnType() == PopII) {
	if (StarClusterUnresolvedModel) {  // Cen & Ostriker
	  ramptime = cstar->ReturnLifetime();
	} else {  // Wise & Cen
	  ramptime = TimeInYears * StarClusterMinDynamicalTime;
	}
      } else if (cstar->ReturnType() == PopIII)
	// should be an parameter or determined from the data
	ramptime = TimeInYears * 10e3;
      else if (cstar->ReturnType() == SimpleSource)
	ramptime = TimeInYears * 1e6 * SimpleRampTime;

      /* Transfer the shining particle properties to the radiative
	 transfer source particle */

      RadiationSourceEntry *RadSource;
      RadSource = cstar->RadiationSourceInitialize();
      RadSource->Luminosity     = QTotal * LConv;
      RadSource->RampTime       = ramptime;
      RadSource->EnergyBins     = nbins;
      RadSource->Energy         = new float[nbins];
      RadSource->SED            = new float[nbins];
      if (RadiativeTransferOpticallyThinH2)
	RadSource->LWLuminosity = Q[3] * LConv;
      else
	RadSource->LWLuminosity = 0.0;
      
      for (j = 0; j < nbins; j++) {
	RadSource->Energy[j] = energies[j];
	RadSource->SED[j]    = Q[j];
      }

      // if the source needs a beaming direction, define it here
      RadSource->Orientation    = NULL;

      if (GlobalRadiationSources->NextSource != NULL)
	GlobalRadiationSources->NextSource->PreviousSource = RadSource;
      GlobalRadiationSources->NextSource = RadSource;
      
    } // ENDIF is a radiation source?

  } // ENDFOR stars

  return SUCCESS;

}
